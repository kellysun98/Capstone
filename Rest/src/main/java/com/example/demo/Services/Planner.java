package com.example.demo.Services;

import org.jxmapviewer.JXMapViewer;

import javax.swing.*;
import java.util.*;
import java.util.List;

public class Planner {
    public JXMapViewer mapViewer;
    public JFrame frame;
    public Graph graph;

    public Planner(Graph graph){
        this.graph = graph;
    }
    /**Astar returns the shortest path from start Node to end Node
     *
     * */
    public LinkedList<MapNode> Astar(MapNode startNode, MapNode goalNode){

        HashMap<MapNode, MapNode> parents = new HashMap<>();
        HashMap<MapNode, Double> costs = new HashMap<>();
        PriorityQueue<MapNode> priorityQueue = new PriorityQueue<MapNode>();

        startNode.estimatedCost = heuristics(startNode,goalNode);
        parents.put(startNode,null);
        costs.put(startNode,0.0);
        priorityQueue.add(startNode);

        while (!priorityQueue.isEmpty()){
            MapNode node = priorityQueue.remove();
            if(node.id == goalNode.id){
                return getGeoList(parents,goalNode);
            }
            for (MapEdge edge:node.edges){
                MapNode nextNode = edge.destinationNode;
                double newCost = costs.get(node) + edge.getEdgeDistance();
                if (!parents.containsKey(nextNode) || newCost < costs.get(nextNode)) {
                    parents.put(nextNode,node);
                    costs.put(nextNode,newCost);
                    nextNode.estimatedCost = heuristics(nextNode,goalNode) + newCost;
                    priorityQueue.add(nextNode);
                }
            }
        }
        return null;
    }
    /** Return a list of MapNode
     * */
    public LinkedList<MapNode> getGeoList(HashMap<MapNode, MapNode> parents, MapNode goalNode){
        Path geoList = new Path();
        geoList.add(goalNode);
        MapNode thisNode = goalNode;
        while(thisNode != null){
            geoList.add(thisNode);
            thisNode = parents.get(thisNode);
        }
        Collections.reverse(geoList.nodes);

        return geoList.nodes;
    }

//    /**
//     * Compute the K shortest paths in a graph from node s to node t using Yen's algorithm
//     *
//     *
//     */
//    public List<HashMap<Double, ArrayList<MapNode>>> ksp(Graph graph, MapNode src, MapNode dest, int K){
//        // initialize containers for candidate paths and K shortest paths
////        ArrayList<List<MapNode>> ksp = new ArrayList<>();
//        ArrayList<Path> ksp = new ArrayList<Path>();
//        PriorityQueue<MapNode> candidates = new PriorityQueue<MapNode>();
//
//        try{
//            // Compute and add the shortest path
//            Path kthPath = new Path();
//            kthPath.nodes = Astar(src, dest);
//            kthPath.totalCost = 0;
//            ksp.add(kthPath);
//
//            // Iteratively compute each of the k shortest paths
//            for (int k = 1; k<K; k++){
//                // Get the (k-1)st shortest path
//                Path previousPath = ksp.get(k-1);
//
//                /* Iterate over all of the nodes in the (k-1)st shortest path except for the target node; for each node,
//                   (up to) one new candidate path is generated by temporarily modifying the graph and then running
//                   A* algorithm to find the shortest path between the node and the target in the modified
//                   graph */
//                for (int i = 0; i < previousPath.size(); i++) {
//                    // Initialize a container to sore the modified/removed edges for this node/iteration
//                    LinkedList<MapEdge> removedEdges = new LinkedList<>();
//
//                    // Spur node = currently visited node in the (k-1)st shortest path
//                    MapNode spurNode = previousPath.getEdges().get(i).getSourceNode();
//
//                    // Root path = prefix portion of the (k-1)st path up to the spur node
//                    Path rootPath = previousPath.cloneTo(i);
//
//                    /* Iterate over all of the (k-1) shortest paths */
//                    for(Path p:ksp) {
//                        Path stub = p.cloneTo(i);
//                        // Check to see if this path has the same prefix/root as the (k-1)st shortest path
//                        if (rootPath.equals(stub)) {
//                            /* If so, eliminate the next edge in the path from the graph (later on, this forces the spur
//                               node to connect the root path with an un-found suffix path) */
//                            MapEdge re = p.getEdges().get(i);
//                            graph.removeEdge(re.getSourceNode(),re.getDestinationNode());
//                            removedEdges.add(re);
//                        }
//                    }
//
//                    /* Temporarily remove all of the nodes in the root path, other than the spur node, from the graph */
//                    for(MapEdge rootPathEdge : rootPath.getEdges()) {
//                        String rn = rootPathEdge.getFromNode();
//                        if (!rn.equals(spurNode)) {
//                            removedEdges.addAll(graph.removeNode(rn));
//                        }
//                    }
//
//                    // Spur path = shortest path from spur node to target node in the reduced graph
//                    Path spurPath = Dijkstra.shortestPath(graph, spurNode, targetLabel);
//
//                    // If a new spur path was identified...
//                    if (spurPath != null) {
//                        // Concatenate the root and spur paths to form the new candidate path
//                        Path totalPath = rootPath.clone();
//                        totalPath.addPath(spurPath);
//
//                        // If candidate path has not been generated previously, add it
//                        if (!candidates.contains(totalPath))
//                            candidates.add(totalPath);
//                    }
//
//                    // Restore all of the edges that were removed during this iteration
//                    graph.addEdges(removedEdges);
//                }
//
//                /* Identify the candidate path with the shortest cost */
//                boolean isNewPath;
//                do {
//                    kthPath = candidates.poll();
//                    isNewPath = true;
//                    if (kthPath != null) {
//                        for (Path p : ksp) {
//                            // Check to see if this candidate path duplicates a previously found path
//                            if (p.equals(kthPath)) {
//                                isNewPath = false;
//                                break;
//                            }
//                        }
//                    }
//                } while(!isNewPath);
//
//                // If there were not any more candidates, stop
//                if (kthPath == null)
//                    break;
//
//                // Add the best, non-duplicate candidate identified as the k shortest path
//                ksp.add(kthPath);
//            }
//        } catch (Exception e) {
//            System.out.println(e);
//            e.printStackTrace();
//        }
//
//        // Return the set of k shortest paths
//        return ksp;
//    }


    public List<MapNode> planBestFirst(MapNode startNode, MapNode goalNode){

        HashMap<MapNode, MapNode> parents = new HashMap<>();
        HashMap<MapNode, Double> costs = new HashMap<>();
        PriorityQueue<MapNode> priorityQueue = new PriorityQueue<MapNode>(); // Create a priority queue for best first search

        startNode.estimatedCost = heuristics(startNode,goalNode);
        parents.put(startNode,null);
        costs.put(startNode,0.0);
        priorityQueue.add(startNode);

        while (!priorityQueue.isEmpty()){
            MapNode node = priorityQueue.remove();
            if(node.id == goalNode.id){
                return getGeoList(parents,goalNode);
            }
            for (MapEdge edge:node.edges){
                MapNode nextNode = edge.destinationNode;
                double newCost = costs.get(node);
                if (!parents.containsKey(nextNode) || newCost < costs.get(nextNode)) {
                    parents.put(nextNode,node);
                    costs.put(nextNode,newCost);
                    nextNode.estimatedCost = heuristics(nextNode,goalNode) + newCost;
                    priorityQueue.add(nextNode);
                }
            }
        }
        return null;
    }

    public List<MapNode> planBreadthFirst(MapNode startNode, MapNode goalNode) {

        HashMap<MapNode, MapNode> parents = new HashMap<>();
        LinkedList<MapNode> queue = new LinkedList<>(); // Create a queue for BFS

        parents.put(startNode,null);
        queue.add(startNode);

        while (!queue.isEmpty()) {
            // Dequeue a vertex from
            MapNode node = queue.poll();
            if(node.id == goalNode.id){
                return getGeoList(parents,goalNode);
            }
            for (MapEdge edge:node.edges){
                MapNode nextNode = edge.destinationNode;

                if (!parents.containsKey(nextNode)) {
                    parents.put(nextNode,node);
                    queue.add(nextNode);
                }
            }
        }
        return null;
    }


    public double heuristics(MapNode node, MapNode goalNode){
        return com.example.demo.Services.Graph.getDistance(node,goalNode);
    }



//    public Path getGeoList(HashMap<MapNode, MapNode> parents, MapNode goalNode){
//        Path geoList = new Path();
//        geoList.add(goalNode);
//        MapNode thisNode = goalNode;
//        while(thisNode != null){
//            geoList.add(thisNode);
//            thisNode = parents.get(thisNode);
//        }
//        Collections.reverse(geoList);
//
//        return geoList;
//    }
/**
    public void initializeMapViewer(){
        mapViewer = new JXMapViewer();

        // Create a TileFactoryInfo for OpenStreetMap
        TileFactoryInfo info = new OSMTileFactoryInfo();
        DefaultTileFactory tileFactory = new DefaultTileFactory(info);
        mapViewer.setTileFactory(tileFactory);
        // Use 8 threads in parallel to load the tiles
        tileFactory.setThreadPoolSize(8);

        // Set the focus
        MapNode toronto = new MapNode(graph.focus[1], graph.focus[0]);
        mapViewer.setZoom(5);
        mapViewer.setAddressLocation(toronto);

        // Add mouse listeners for panning and zooming
        MouseInputListener mia = new PanMouseInputListener(mapViewer);
        mapViewer.addMouseListener(mia);
        mapViewer.addMouseMotionListener(mia);
        mapViewer.addMouseListener(new CenterMapListener(mapViewer));
        mapViewer.addMouseWheelListener(new ZoomMouseWheelListenerCursor(mapViewer));
        mapViewer.addKeyListener(new PanKeyListener(mapViewer));

        // Add mouse listener for placing waypoints
        frame = new JFrame("OpenStreetAStar");
        WayPointAdapter wayPointAdapter = new WayPointAdapter(mapViewer, graph.routeNodes, this, frame);

        // Display the viewer in a JFrame
        frame.setLayout(new BorderLayout());
        String text = "Use left mouse button to pan, mouse wheel to zoom and right mouse button to set waypoints";
        frame.add(new JLabel(text), BorderLayout.NORTH);
        frame.getContentPane().add(mapViewer);
        frame.setSize(800, 800);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
*/

    public List<List<Double>> getCoordinates(List<MapNode> plan_result){
        List<List<Double>> coordinates = new ArrayList<>();
        for(MapNode mapnode:plan_result){
            List<Double> one_coor = new ArrayList<>();
            one_coor.add(mapnode.longitude);
            one_coor.add(mapnode.latitude);
            coordinates.add(one_coor);
        }
        return coordinates;
    }

    public List<List<List<Double>>> runSearches(MapNode startNode, MapNode endNode){
        List<List<List<Double>>> solutions = new ArrayList<>();
        solutions.add(getCoordinates(Astar(startNode, endNode)));
        System.out.println("solutions: " + solutions);
        //solutions.add(plan(startNode, endNode,"distance"));

//        solutions.add(plan(startNode, endNode,"bikeLane"));
//        solutions.add(plan(startNode, endNode,"accidents"));
//        solutions.add(planBreadthFirst(startNode, endNode));
//        solutions.add(planBestFirst(startNode, endNode));
//        solutions.add(plan(startNode, endNode,"allFeatures"));
        return solutions;
    }


    public static void main(String[] args){
        String osmFile = "C://Users//Helen Wang//Documents//4th_yr//capstone//Capstone//Rest//data//toronto.osm";
        String cyclistFile = "C://Users//Helen Wang//Documents//4th_yr//capstone//Capstone//Rest//data//Cyclists.csv";
        Graph torontoGraph = new Graph(osmFile, cyclistFile);
        Planner planner = new Planner(torontoGraph);
//        planner.initializeMapViewer();
    }

}
